//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MipsInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    536870923U,	// ADD
    536870928U,	// ADDi
    536870934U,	// ADDiu
    536870941U,	// ADDu
    1073741859U,	// ADJCALLSTACKDOWN
    1073741878U,	// ADJCALLSTACKUP
    536870983U,	// AND
    537919564U,	// ANDi
    82U,	// ATMACRO
    537395290U,	// ATOMIC_CMP_SWAP_I16
    537395310U,	// ATOMIC_CMP_SWAP_I32
    537395330U,	// ATOMIC_CMP_SWAP_I8
    536871061U,	// ATOMIC_LOAD_ADD_I16
    536871081U,	// ATOMIC_LOAD_ADD_I32
    536871101U,	// ATOMIC_LOAD_ADD_I8
    536871120U,	// ATOMIC_LOAD_AND_I16
    536871140U,	// ATOMIC_LOAD_AND_I32
    536871160U,	// ATOMIC_LOAD_AND_I8
    536871179U,	// ATOMIC_LOAD_NAND_I16
    536871200U,	// ATOMIC_LOAD_NAND_I32
    536871221U,	// ATOMIC_LOAD_NAND_I8
    536871241U,	// ATOMIC_LOAD_OR_I16
    536871260U,	// ATOMIC_LOAD_OR_I32
    536871279U,	// ATOMIC_LOAD_OR_I8
    536871297U,	// ATOMIC_LOAD_SUB_I16
    536871317U,	// ATOMIC_LOAD_SUB_I32
    536871337U,	// ATOMIC_LOAD_SUB_I8
    536871356U,	// ATOMIC_LOAD_XOR_I16
    536871376U,	// ATOMIC_LOAD_XOR_I32
    536871396U,	// ATOMIC_LOAD_XOR_I8
    536871415U,	// ATOMIC_SWAP_I16
    536871431U,	// ATOMIC_SWAP_I32
    536871447U,	// ATOMIC_SWAP_I8
    603980326U,	// BC1F
    603980332U,	// BC1FL
    603980339U,	// BC1T
    603980345U,	// BC1TL
    536871488U,	// BEQ
    538968645U,	// BGEZ
    538968651U,	// BGEZAL
    538968659U,	// BGTZ
    538968665U,	// BLEZ
    538968671U,	// BLTZ
    538968677U,	// BLTZAL
    536871533U,	// BNE
    0U,	// BuildPairF64
    538968690U,	// CEIL_LD
    538968690U,	// CEIL_LS
    538968698U,	// CEIL_W_D32
    538968708U,	// CEIL_W_S32
    538968718U,	// CFC1
    538968724U,	// CLO
    538968729U,	// CLZ
    603980446U,	// CPLOAD
    603980455U,	// CPRESTORE
    1744831155U,	// CTC1
    538968761U,	// CVTD_L32
    538968770U,	// CVTD_S32
    538968779U,	// CVTD_W32
    538968788U,	// CVTL_D
    538968788U,	// CVTL_S
    538968795U,	// CVTS_D32
    538968804U,	// CVTS_L32
    538968813U,	// CVTS_W32
    538968822U,	// CVTW_D32
    538968831U,	// CVTW_S32
    545259542U,	// DynAlloc
    0U,	// ExtractElementF64
    538968840U,	// FABS_D32
    538968847U,	// FABS_S32
    536871702U,	// FADD_D32
    536871709U,	// FADD_S32
    2348811044U,	// FCMP_D32
    2415919908U,	// FCMP_S32
    536871719U,	// FDIV_D32
    536871726U,	// FDIV_S32
    538968885U,	// FLOOR_LD
    538968885U,	// FLOOR_LS
    538968894U,	// FLOOR_W_D32
    538968905U,	// FLOOR_W_S32
    538968916U,	// FMOV_D32
    538968923U,	// FMOV_S32
    536871778U,	// FMUL_D32
    536871785U,	// FMUL_S32
    538968944U,	// FNEG_D32
    538968951U,	// FNEG_S32
    538968958U,	// FSQRT_D32
    538968966U,	// FSQRT_S32
    536871822U,	// FSUB_D32
    536871829U,	// FSUB_S32
    603980700U,	// J
    603980703U,	// JAL
    603980708U,	// JALR
    603980714U,	// JR
    553649070U,	// LB
    553649074U,	// LBu
    553649079U,	// LDC1
    545259542U,	// LEA_ADDiu
    553649085U,	// LH
    553649089U,	// LHu
    553649094U,	// LL
    562037706U,	// LUi
    553649103U,	// LW
    553649107U,	// LWC1
    985U,	// MACRO
    538969060U,	// MADD
    538969066U,	// MADDU
    538969073U,	// MFC1
    603980791U,	// MFHI
    603980797U,	// MFLO
    1027U,	// MOVCCRToCCR
    541066257U,	// MOVF
    541066263U,	// MOVF_D
    541066271U,	// MOVF_S
    536871975U,	// MOVN_D
    536871983U,	// MOVN_I
    536871989U,	// MOVN_S
    541066301U,	// MOVT
    541066307U,	// MOVT_D
    541066315U,	// MOVT_S
    536872019U,	// MOVZ_D
    536872027U,	// MOVZ_I
    536872033U,	// MOVZ_S
    538969193U,	// MSUB
    538969199U,	// MSUBU
    1744831606U,	// MTC1
    603980924U,	// MTHI
    603980930U,	// MTLO
    536872072U,	// MUL
    538969229U,	// MULT
    538969235U,	// MULTu
    1178U,	// NOAT
    1188U,	// NOMACRO
    1201U,	// NOP
    536872117U,	// NOR
    1210U,	// NOREORDER
    536872137U,	// OR
    537920717U,	// ORi
    538969298U,	// RDHWR
    1241U,	// REORDER
    603980714U,	// RET
    536872166U,	// ROTR
    570426604U,	// ROTRV
    538969331U,	// ROUND_LD
    538969331U,	// ROUND_LS
    538969340U,	// ROUND_W_D32
    538969351U,	// ROUND_W_S32
    553649426U,	// SB
    1946158358U,	// SC
    553649434U,	// SDC1
    538969376U,	// SDIV
    538969388U,	// SEB
    538969393U,	// SEH
    553649462U,	// SH
    536872250U,	// SLL
    570426687U,	// SLLV
    536872261U,	// SLT
    536872266U,	// SLTi
    536872272U,	// SLTiu
    536872279U,	// SLTu
    536872285U,	// SRA
    570426722U,	// SRAV
    536872296U,	// SRL
    570426733U,	// SRLV
    536872307U,	// SUB
    536872312U,	// SUBu
    553649534U,	// SW
    553649538U,	// SWC1
    603981192U,	// SYNC
    538969486U,	// TRUNC_LD
    538969486U,	// TRUNC_LS
    538969495U,	// TRUNC_W_D32
    538969506U,	// TRUNC_W_S32
    538969517U,	// UDIV
    538969530U,	// WSBW
    536872384U,	// XOR
    537920965U,	// XORi
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000add\t\000addi\t\000addiu\t\000addu\t\000!ADJCALLSTACKDOWN "
    "\000!ADJCALLSTACKUP \000and\t\000andi\t\000.set\tat\000atomic_cmp_swap_"
    "16\t\000atomic_cmp_swap_32\t\000atomic_cmp_swap_8\t\000atomic_load_add_"
    "16\t\000atomic_load_add_32\t\000atomic_load_add_8\t\000atomic_load_and_"
    "16\t\000atomic_load_and_32\t\000atomic_load_and_8\t\000atomic_load_nand"
    "_16\t\000atomic_load_nand_32\t\000atomic_load_nand_8\t\000atomic_load_o"
    "r_16\t\000atomic_load_or_32\t\000atomic_load_or_8\t\000atomic_load_sub_"
    "16\t\000atomic_load_sub_32\t\000atomic_load_sub_8\t\000atomic_load_xor_"
    "16\t\000atomic_load_xor_32\t\000atomic_load_xor_8\t\000atomic_swap_16\t"
    "\000atomic_swap_32\t\000atomic_swap_8\t\000bc1f\t\000bc1fl\t\000bc1t\t\000"
    "bc1tl\t\000beq\t\000bgez\t\000bgezal\t\000bgtz\t\000blez\t\000bltz\t\000"
    "bltzal\t\000bne\t\000ceil.l\t\000ceil.w.d\t\000ceil.w.s\t\000cfc1\t\000"
    "clo\t\000clz\t\000.cpload\t\000.cprestore\t\000ctc1\t\000cvt.d.l\t\000c"
    "vt.d.s\t\000cvt.d.w\t\000cvt.l\t\000cvt.s.d\t\000cvt.s.l\t\000cvt.s.w\t"
    "\000cvt.w.d\t\000cvt.w.s\t\000abs.d\t\000abs.s\t\000add.d\t\000add.s\t\000"
    "c.\000div.d\t\000div.s\t\000floor.l\t\000floor.w.d\t\000floor.w.s\t\000"
    "mov.d\t\000mov.s\t\000mul.d\t\000mul.s\t\000neg.d\t\000neg.s\t\000sqrt."
    "d\t\000sqrt.s\t\000sub.d\t\000sub.s\t\000j\t\000jal\t\000jalr\t\000jr\t"
    "\000lb\t\000lbu\t\000ldc1\t\000lh\t\000lhu\t\000ll\t\000lui\t\000lw\t\000"
    "lwc1\t\000.set\tmacro\000madd\t\000maddu\t\000mfc1\t\000mfhi\t\000mflo\t"
    "\000# MOVCCRToCCR\000movf\t\000movf.d\t\000movf.s\t\000movn.d\t\000movn"
    "\t\000movn.s\t\000movt\t\000movt.d\t\000movt.s\t\000movz.d\t\000movz\t\000"
    "movz.s\t\000msub\t\000msubu\t\000mtc1\t\000mthi\t\000mtlo\t\000mul\t\000"
    "mult\t\000multu\t\000.set\tnoat\000.set\tnomacro\000nop\000nor\t\000.se"
    "t\tnoreorder\000or\t\000ori\t\000rdhwr\t\000.set\treorder\000rotr\t\000"
    "rotrv\t\000round.l\t\000round.w.d\t\000round.w.s\t\000sb\t\000sc\t\000s"
    "dc1\t\000div\t$zero, \000seb\t\000seh\t\000sh\t\000sll\t\000sllv\t\000s"
    "lt\t\000slti\t\000sltiu\t\000sltu\t\000sra\t\000srav\t\000srl\t\000srlv"
    "\t\000sub\t\000subu\t\000sw\t\000swc1\t\000sync \000trunc.l\t\000trunc."
    "w.d\t\000trunc.w.s\t\000divu\t$zero, \000wsbw\t\000xor\t\000xori\t\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 2047)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ATMACRO, MACRO, MOVCCRToCCR, NOAT, NOMACRO, NOP, NOREORDER,...
    return;
    break;
  case 1:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWA...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP
    printUnsignedImm(MI, 0, O); 
    return;
    break;
  case 3:
    // CTC1, MTC1, SC
    printOperand(MI, 1, O); 
    O << ", "; 
    break;
  case 4:
    // FCMP_D32, FCMP_S32
    printFCCOperand(MI, 2, O); 
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWA...
    O << ", "; 
    break;
  case 1:
    // BC1F, BC1FL, BC1T, BC1TL, CPLOAD, CPRESTORE, J, JAL, JALR, JR, MFHI, M...
    return;
    break;
  case 2:
    // CTC1, MTC1
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // FCMP_D32
    O << ".d\t"; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 4:
    // FCMP_S32
    O << ".s\t"; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 5:
    // SC
    printMemOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 23) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWA...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // DynAlloc, LEA_ADDiu
    printMemOperandEA(MI, 1, O); 
    return;
    break;
  case 2:
    // LB, LBu, LDC1, LH, LHu, LL, LW, LWC1, SB, SDC1, SH, SW, SWC1
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // LUi
    printUnsignedImm(MI, 1, O); 
    return;
    break;
  case 4:
    // ROTRV, SLLV, SRAV, SRLV
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 21) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWA...
    O << ", "; 
    break;
  case 1:
    // BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL, CEIL_LD, CEIL_LS, CEIL_W_D32, ...
    return;
    break;
  case 2:
    // MOVF, MOVF_D, MOVF_S, MOVT, MOVT_D, MOVT_S
    O << ", $fcc0"; 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // ANDi, ORi, XORi
    printUnsignedImm(MI, 2, O); 
    return;
  } else {
    // ADD, ADDi, ADDiu, ADDu, AND, ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWAP_I32,...
    printOperand(MI, 2, O); 
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 19) & 1) {
    // ATOMIC_CMP_SWAP_I16, ATOMIC_CMP_SWAP_I32, ATOMIC_CMP_SWAP_I8
    O << ", "; 
    printOperand(MI, 3, O); 
    return;
  } else {
    // ADD, ADDi, ADDiu, ADDu, AND, ATOMIC_LOAD_ADD_I16, ATOMIC_LOAD_ADD_I32,...
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MipsInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 85 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 2, 4, 6, 8, 11, 14, 17, 20, 23, 26, 30, 34, 38,
    42, 46, 50, 54, 58, 62, 66, 11, 70, 14, 73, 17, 76, 20,
    79, 23, 82, 26, 85, 30, 89, 34, 93, 38, 97, 42, 101, 46,
    105, 50, 109, 54, 113, 58, 117, 62, 121, 66, 125, 129, 132, 135,
    138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177,
    180, 183, 185, 187, 190, 193, 196, 199, 202, 205, 208, 211, 213, 215,
    0
  };

  const char *AsmStrs =
    "4\0005\0006\0007\000AT\000F0\000F2\000F4\000F6\000F8\000F10\000F12\000F"
    "14\000F16\000F18\000F20\000F22\000F24\000F26\000F28\000F30\000F1\000F3\000"
    "F5\000F7\000F9\000F11\000F13\000F15\000F17\000F19\000F21\000F23\000F25\000"
    "F27\000F29\000F31\00031\000FP\000GP\000hi\00029\00026\00027\000lo\000RA"
    "\00016\00017\00018\00019\00020\00021\00022\00023\000SP\0008\0009\00010\000"
    "11\00012\00013\00014\00015\00024\00025\0002\0003\000ZERO\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MipsInstPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 191 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 155, 160, 166, 171, 188, 203, 207, 212, 220, 240, 260, 279, 299, 
    319, 338, 358, 378, 397, 418, 439, 459, 478, 497, 515, 535, 555, 574, 
    594, 614, 633, 649, 665, 680, 685, 691, 696, 702, 706, 711, 718, 723, 
    728, 733, 740, 744, 757, 765, 773, 784, 795, 800, 804, 808, 815, 825, 
    830, 839, 848, 857, 864, 871, 880, 889, 898, 907, 916, 925, 943, 952, 
    961, 970, 979, 988, 997, 1006, 1015, 1024, 1033, 1045, 1057, 1066, 1075, 1084, 
    1093, 1102, 1111, 1121, 1131, 1140, 1149, 1151, 1155, 1160, 1163, 1166, 1170, 1175, 
    1185, 1188, 1192, 1195, 1199, 1202, 1207, 1213, 1218, 1224, 1229, 1234, 1239, 1251, 
    1256, 1263, 1270, 1277, 1284, 1291, 1296, 1303, 1310, 1317, 1324, 1331, 1336, 1342, 
    1347, 1352, 1357, 1361, 1366, 1372, 1377, 1385, 1389, 1393, 1403, 1406, 1410, 1416, 
    1424, 1428, 1433, 1439, 1448, 1457, 1469, 1481, 1484, 1487, 1492, 1497, 1501, 1505, 
    1508, 1512, 1517, 1521, 1526, 1532, 1537, 1541, 1546, 1550, 1555, 1559, 1564, 1567, 
    1572, 1577, 1586, 1595, 1607, 1619, 1624, 1629, 1633, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADD\000ADDi\000ADDiu"
    "\000ADDu\000ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000AND\000ANDi\000ATMACR"
    "O\000ATOMIC_CMP_SWAP_I16\000ATOMIC_CMP_SWAP_I32\000ATOMIC_CMP_SWAP_I8\000"
    "ATOMIC_LOAD_ADD_I16\000ATOMIC_LOAD_ADD_I32\000ATOMIC_LOAD_ADD_I8\000ATO"
    "MIC_LOAD_AND_I16\000ATOMIC_LOAD_AND_I32\000ATOMIC_LOAD_AND_I8\000ATOMIC"
    "_LOAD_NAND_I16\000ATOMIC_LOAD_NAND_I32\000ATOMIC_LOAD_NAND_I8\000ATOMIC"
    "_LOAD_OR_I16\000ATOMIC_LOAD_OR_I32\000ATOMIC_LOAD_OR_I8\000ATOMIC_LOAD_"
    "SUB_I16\000ATOMIC_LOAD_SUB_I32\000ATOMIC_LOAD_SUB_I8\000ATOMIC_LOAD_XOR"
    "_I16\000ATOMIC_LOAD_XOR_I32\000ATOMIC_LOAD_XOR_I8\000ATOMIC_SWAP_I16\000"
    "ATOMIC_SWAP_I32\000ATOMIC_SWAP_I8\000BC1F\000BC1FL\000BC1T\000BC1TL\000"
    "BEQ\000BGEZ\000BGEZAL\000BGTZ\000BLEZ\000BLTZ\000BLTZAL\000BNE\000Build"
    "PairF64\000CEIL_LD\000CEIL_LS\000CEIL_W_D32\000CEIL_W_S32\000CFC1\000CL"
    "O\000CLZ\000CPLOAD\000CPRESTORE\000CTC1\000CVTD_L32\000CVTD_S32\000CVTD"
    "_W32\000CVTL_D\000CVTL_S\000CVTS_D32\000CVTS_L32\000CVTS_W32\000CVTW_D3"
    "2\000CVTW_S32\000DynAlloc\000ExtractElementF64\000FABS_D32\000FABS_S32\000"
    "FADD_D32\000FADD_S32\000FCMP_D32\000FCMP_S32\000FDIV_D32\000FDIV_S32\000"
    "FLOOR_LD\000FLOOR_LS\000FLOOR_W_D32\000FLOOR_W_S32\000FMOV_D32\000FMOV_"
    "S32\000FMUL_D32\000FMUL_S32\000FNEG_D32\000FNEG_S32\000FSQRT_D32\000FSQ"
    "RT_S32\000FSUB_D32\000FSUB_S32\000J\000JAL\000JALR\000JR\000LB\000LBu\000"
    "LDC1\000LEA_ADDiu\000LH\000LHu\000LL\000LUi\000LW\000LWC1\000MACRO\000M"
    "ADD\000MADDU\000MFC1\000MFHI\000MFLO\000MOVCCRToCCR\000MOVF\000MOVF_D\000"
    "MOVF_S\000MOVN_D\000MOVN_I\000MOVN_S\000MOVT\000MOVT_D\000MOVT_S\000MOV"
    "Z_D\000MOVZ_I\000MOVZ_S\000MSUB\000MSUBU\000MTC1\000MTHI\000MTLO\000MUL"
    "\000MULT\000MULTu\000NOAT\000NOMACRO\000NOP\000NOR\000NOREORDER\000OR\000"
    "ORi\000RDHWR\000REORDER\000RET\000ROTR\000ROTRV\000ROUND_LD\000ROUND_LS"
    "\000ROUND_W_D32\000ROUND_W_S32\000SB\000SC\000SDC1\000SDIV\000SEB\000SE"
    "H\000SH\000SLL\000SLLV\000SLT\000SLTi\000SLTiu\000SLTu\000SRA\000SRAV\000"
    "SRL\000SRLV\000SUB\000SUBu\000SW\000SWC1\000SYNC\000TRUNC_LD\000TRUNC_L"
    "S\000TRUNC_W_D32\000TRUNC_W_S32\000UDIV\000WSBW\000XOR\000XORi\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_AFGR64,
    RC_CCR,
    RC_CPURegs,
    RC_FGR32,
    RC_HILO,
    RC_HWRegs
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_AFGR64:
    switch (Reg) {
    default: break;
    case Mips::D0:
    case Mips::D1:
    case Mips::D6:
    case Mips::D7:
    case Mips::D2:
    case Mips::D3:
    case Mips::D4:
    case Mips::D5:
    case Mips::D8:
    case Mips::D9:
    case Mips::D10:
    case Mips::D11:
    case Mips::D12:
    case Mips::D13:
    case Mips::D14:
    case Mips::D15:
      return true;
    }
    break;
  case RC_CCR:
    if (Reg == Mips::FCR31)
      return true;
    break;
  case RC_CPURegs:
    switch (Reg) {
    default: break;
    case Mips::V0:
    case Mips::V1:
    case Mips::A0:
    case Mips::A1:
    case Mips::A2:
    case Mips::A3:
    case Mips::T0:
    case Mips::T1:
    case Mips::T2:
    case Mips::T3:
    case Mips::T4:
    case Mips::T5:
    case Mips::T6:
    case Mips::T7:
    case Mips::T8:
    case Mips::T9:
    case Mips::S0:
    case Mips::S1:
    case Mips::S2:
    case Mips::S3:
    case Mips::S4:
    case Mips::S5:
    case Mips::S6:
    case Mips::S7:
    case Mips::ZERO:
    case Mips::AT:
    case Mips::K0:
    case Mips::K1:
    case Mips::GP:
    case Mips::SP:
    case Mips::FP:
    case Mips::RA:
      return true;
    }
    break;
  case RC_FGR32:
    switch (Reg) {
    default: break;
    case Mips::F0:
    case Mips::F1:
    case Mips::F2:
    case Mips::F3:
    case Mips::F4:
    case Mips::F5:
    case Mips::F6:
    case Mips::F7:
    case Mips::F8:
    case Mips::F9:
    case Mips::F10:
    case Mips::F11:
    case Mips::F12:
    case Mips::F13:
    case Mips::F14:
    case Mips::F15:
    case Mips::F16:
    case Mips::F17:
    case Mips::F18:
    case Mips::F19:
    case Mips::F20:
    case Mips::F21:
    case Mips::F22:
    case Mips::F23:
    case Mips::F24:
    case Mips::F25:
    case Mips::F26:
    case Mips::F27:
    case Mips::F28:
    case Mips::F29:
    case Mips::F30:
    case Mips::F31:
      return true;
    }
    break;
  case RC_HILO:
    switch (Reg) {
    default: break;
    case Mips::HI:
    case Mips::LO:
      return true;
    }
    break;
  case RC_HWRegs:
    if (Reg == Mips::HWR29)
      return true;
    break;
  }

  return false;
}

bool MipsInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
